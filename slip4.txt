# Define two matrices of the same size
matrix1 <- matrix(c(1,2,3,4,5,6), nrow=2, ncol=3)
matrix2 <- matrix(c(6,5,4,3,2,1), nrow=2, ncol=3)

# Sum of matrices
sum_matrix <- matrix1 + matrix2

# Display result
print(sum_matrix)





import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.naive_bayes import GaussianNB

# Dataset
weather = ['Sunny', 'Sunny', 'Overcast', 'Rainy', 'Rainy', 'Rainy', 'Overcast', 'Sunny', 'Sunny', 'Rainy', 'Sunny', 'Overcast', 'Overcast', 'Rainy']
temp    = ['Hot', 'Hot', 'Hot', 'Mild', 'Cool', 'Cool', 'Cool', 'Mild', 'Cool', 'Mild', 'Mild', 'Mild', 'Hot', 'Mild']
play    = ['No', 'No', 'Yes', 'Yes', 'No', 'Yes', 'No', 'Yes', 'Yes', 'Yes', 'Yes', 'Yes', 'Yes', 'No']

# Create DataFrame
df = pd.DataFrame({'Weather': weather, 'Temp': temp, 'Play': play})

# Encode categorical features
le_weather = LabelEncoder()
le_temp = LabelEncoder()
le_play = LabelEncoder()

df['Weather'] = le_weather.fit_transform(df['Weather'])
df['Temp'] = le_temp.fit_transform(df['Temp'])
df['Play'] = le_play.fit_transform(df['Play'])

# Features and target
X = df[['Weather', 'Temp']]
y = df['Play']

# Train Gaussian Naive Bayes
model = GaussianNB()
model.fit(X, y)

# Predict for tuple: ('Overcast', 'Mild')
sample = [[le_weather.transform(['Overcast'])[0], le_temp.transform(['Mild'])[0]]]
prediction = model.predict(sample)

# Decode prediction
pred_class = le_play.inverse_transform(prediction)
print("Predicted class for ('Overcast', 'Mild'):", pred_class[0])
